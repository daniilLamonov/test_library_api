# Library Backend
Это Тестовое Задание для Стажера Python-Разработчика: API для Библиотеки

## База данных

Этот проект использует **PostgreSQL** для хранения запросов. Для локальной работы потребуется установить БД на компьютер, либо воспользоваться контейнером.
Все зависимости БД находятся в файле .env в корне проекта.

## Установка и запуск
*  Клонируйте репозиторий:
```console
git clone https://github.com/daniilLamonov/test_library_api.git
cd test_library_api
```
* Синхронизируйте зависимости с помощью uv:
```console
uv sync
```
* Запустите контейнер PostgreSQL (если не установлен локально).
**Убедитесь, что переменные окружения в файле .env настроены корректно.**
* Примените миграции базы данных с помощью Alembic:
```console
alembic upgrade head
```
* Запустите приложение:
```console
uvicorn app.main:app --reload
```

## Docker
**Если бд установлена локально измени host в .env на "host.docker.internal"** <br>

Есть возможность запуска приложения через докер. Пример команды сборки контейнера:
```console
docker build -t lib .
```
И запуска:
```console
docker run --rm -d -p 8000:8000 --name lib_back lib:latest
```
## Структура проекта

* app/ — основное приложение, включая модели, схемы, сервисы и маршруты.
* tests/ — модульные и интеграционные тесты.
* alembic/ — миграции базы данных.

## Принятые решения по структуре БД

База данных построена на PostgreSQL и включает следующие основные таблицы:

* users — хранит информацию о пользователях(библиотекарях).
* books — содержит данные о книгах.
* borrowed_books — отслеживает бронирования книг пользователями.
* readers - хранит информацию о читателях, зарегистрированных библиотекарями
Выбор PostgreSQL обусловлен ее надежностью и поддержкой сложных запросов, что важно для управления связями между пользователями и книгами.


## Реализация бизнес-логики

4.1 Бизнес-логика 1: Книгу можно выдать, только если есть доступные экземпляры (количество экземпляров > 0). При выдаче количество экземпляров уменьшается на 1.
В эндпоинте /library/give_book принимаются три параметра пути, id книги, id читателя и количество книг. 
После функция получает из базы книгу и читателя, проверяя их на наличие по данным uuid, после у книги проверяется параметр count и, если он больше 1, функция продолжает выполнение.

4.2 Один читатель не может взять более 3-х книг одновременно.
В эндпоинте /library/give_book после получения и проверки книги и читателя, из базы берется debts(все долги читателя). 
Создается переменная - общее количество, куда записывается сумма к выдаче и сумма книг из долгов, и если эта общая сумма
превышает 3, то вызывается ошибка. Если же ситуация обратная, то создается объект borrow(одолжение),
а у книги в бд обновляется параметр count(вычитается 1). 

4.3 Бронирование книг
В эндпоинте /library/return_book функция получает и проверяет книгу и читателя по параметрам запроса, 
а после получает заимствование borrow из бд, по uuid книги и пользователя. В базе данных же выполняется сначала подзапрос на получение первого заимствования, 
где нет даты возврата(поскольку один читатель может взять несколько одинаковых книг в разное время), а после и запрос на добавление даты возврата. Таким образом, 
если книга уже была возвращена она отфильтруется на подзапросе, а если вообще не была взята, то и не будет найдена по ключам.
## Аутентификация
### Генерация и проверка токенов
Используется JWT для аутентификации и oauth2_scheme(для удобного извлечения токена из заголовка).
При входе пользователь получает токен, который должен быть предоставлен в заголовке Authorization для доступа к защищенным эндпоинтам.
### Защищенные эндпоинты
Эндпоинты, связанные с управлением книгами и читателями, защищены и требуют наличия действительного токена. 
Однако эндпоинты для просмотра всех книг или какой либо конкретной, не защищены, для предоставления данных о доступных книгах всем желающим.

## Дополнительная фича: Рассылка информации по email

Идея: Добавить рассылку читателям email с информации о взятии книги и сроках возврата.

Реализация:

* Поле email у читателя есть, это упрощает задачу
* Зададим параметры почты для отправок(можно использовать выделенную или сторонний сервис) в настроечных файлах
* Создадим приложение Celery для фоновой отправки и запустим redis в качестве брокера задач
* Создадим Celery задачу в виде функции принимающей reader.email и объект borrow
* Далее функция парсит данные borrow в читабельный текст для клиента и создает объект EmailMessage, куда передает все данные, а после отправляет письмо через smtplib
* После в эндпоинте /give_book вызывем функцию через метод delay


**! Также можно вынести в отдельный файл функцию по созданию шаблона письма, чтобы после переиспользовать функцию отправки, для например напоминаний через другой шаблон**
